/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./SRC.app/scripts/app.js":
/*!********************************!*\
  !*** ./SRC.app/scripts/app.js ***!
  \********************************/
/***/ (() => {

eval("\r\n/*jshint esversion: 6 */\r\n\r\nconsole.info(\"[ V__ARENA - < Var__v-0.1-72 > ]\");\r\n(function() {\r\n  const FADE_TIME = 150; // ms\r\n  const TYPING_TIMER_LENGTH = 400; // ms\r\n  const COLORS = [\r\n    '#e21400', '#91580f', '#f8a700', '#f78b00',\r\n    '#58dc00', '#287b00', '#a8f07a', '#4ae8c4',\r\n    '#3b88eb', '#3824aa', '#a700ff', '#d300e7'\r\n  ];\r\n\r\n  const vDOM = (elemSelector = null) => {\r\n    if (elemSelector === null) {\r\n      return document;\r\n    } else {\r\n      var elem = document.querySelector(elemSelector);\r\n      return elem;\r\n    }\r\n  };\r\n  // Initialize variables\r\n  const $window = window;\r\n  const $usernameInput = vDOM('.usernameInput'); // Input for username\r\n  const $passwordInput = vDOM('.passwordInput'); // Input for password\r\n  const $messages = vDOM('.messages');           // Messages area\r\n  const $inputMessage = vDOM('.inputMessage');   // Input message input box\r\n\r\n  const $loginPage = vDOM('.login.page');        // The login page\r\n  const $chatPage = vDOM('.chat.page');          // The chatroom page\r\n\r\n  const socket = io();\r\n\r\n  // Prompt for setting a username\r\n  let username;\r\n  let connected = false;\r\n  let typing = false;\r\n  let lastTypingTime;\r\n  let $currentInput = $usernameInput;\r\n\r\n  const addParticipantsMessage = (data) => {\r\n    let message = '';\r\n    if (data.liveUsersCount === 1) {\r\n      message += `there's 1 participant`;\r\n    } else {\r\n      message += `there are ${data.liveUsersCount} participants`;\r\n    }\r\n    log(message);\r\n  };\r\n\r\n  // Sets the client's username\r\n  const setUsername = () => {\r\n    username = cleanInput($usernameInput.value.trim());\r\n    var password = cleanInput($passwordInput.value.trim());\r\n\r\n    // If the username is valid\r\n    if (username && password) {\r\n      // Tell the server your username\r\n      socket.emit('login user', username, password);\r\n    } else {\r\n      alert('username or password is missing or invalid');\r\n    }\r\n  };\r\n\r\n  // Sends a chat message\r\n  const sendMessage = () => {\r\n    let message = $inputMessage.value;\r\n    // Prevent markup from being injected into the message\r\n    message = cleanInput(message);\r\n    // if there is a non-empty message and a socket connection\r\n    if (message && connected) {\r\n      $inputMessage.value = \"\";\r\n      addChatMessage({ username, message });\r\n      // tell server to execute 'new message' and send along one parameter\r\n      socket.emit('new message', message);\r\n    }\r\n  };\r\n\r\n  // Log a message\r\n  const log = (message, options) => {\r\n    const $el = '<li class=\"log\">'+(message)+'</li>';\r\n    addMessageElement($el, options);\r\n  };\r\n\r\n  // Adds the visual chat message to the message list\r\n  const addChatMessage = (data, options = {}) => {\r\n    // Don't fade the message in if there is an 'X was typing'\r\n    const $typingMessages = getTypingMessages(data);\r\n    if ($typingMessages.length !== 0) {\r\n      options.fade = false;\r\n      $typingMessages.forEach( item => {\r\n        item.remove();\r\n      });\r\n    }\r\n\r\n    const $usernameDiv = '<span class=\"username\" style=\"color : '+getUsernameColor(data.username)+'\">'+data.username+'</span>';\r\n    const $messageBodyDiv = '<span class=\"messageBody\">'+(data.message)+'</span>';\r\n\r\n    const typingClass = data.typing ? 'typing' : '';\r\n    const $messageDiv = '<li class=\"message '+typingClass+'\" username=\"'+data.username+'\">'+$usernameDiv + $messageBodyDiv + '</li>';\r\n\r\n    addMessageElement($messageDiv, options);\r\n  };\r\n\r\n  // Adds the visual chat typing message\r\n  const addChatTyping = (data) => {\r\n    data.typing = true;\r\n    data.message = 'is typing';\r\n    addChatMessage(data);\r\n  };\r\n\r\n  // Removes the visual chat typing message\r\n  const removeChatTyping = (data) => {\r\n    getTypingMessages(data).forEach( item => {\r\n      item.remove();\r\n    });\r\n  };\r\n\r\n  // Adds a message element to the messages and scrolls to the bottom\r\n  // el - The element to add as a message\r\n  // options.fade - If the element should fade-in (default = true)\r\n  // options.prepend - If the element should prepend\r\n  //   all other messages (default = false)\r\n  const addMessageElement = (el, options) => {\r\n    const $el = el;\r\n    // Setup default options\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n    if (typeof options.fade === 'undefined') {\r\n      options.fade = true;\r\n    }\r\n    if (typeof options.prepend === 'undefined') {\r\n      options.prepend = false;\r\n    }\r\n\r\n    // Apply options\r\n    //if (options.fade) {\r\n    //  $el.hide().fadeIn(FADE_TIME);\r\n    //}\r\n    if (options.prepend) {\r\n      $messages.insertAdjacentHTML('afterbegin', $el);\r\n    } else {\r\n      $messages.insertAdjacentHTML('beforeend', $el);\r\n    }\r\n    // First check that the element has child nodes\r\n    if ($messages.hasChildNodes()) {\r\n      let children = $messages.childNodes;\r\n      console.info(\"CHILDREN >> \" + children.length);\r\n      for (let i = 0; i < children.length; i++) {\r\n        // do something with each child as children[i]\r\n        // NOTE: List is live! Adding or removing children will change the list's `length`\r\n        children[0].scrollTop = children[0].scrollHeight;\r\n      }\r\n    }\r\n  };\r\n\r\n  // Prevents input from having injected markup\r\n  const cleanInput = (input) => {\r\n    return input;\r\n  };\r\n\r\n  // Updates the typing event\r\n  const updateTyping = () => {\r\n    if (connected) {\r\n      if (!typing) {\r\n        typing = true;\r\n        socket.emit('typing');\r\n      }\r\n      lastTypingTime = (new Date()).getTime();\r\n\r\n      setTimeout(() => {\r\n        const typingTimer = (new Date()).getTime();\r\n        const timeDiff = typingTimer - lastTypingTime;\r\n        if (timeDiff >= TYPING_TIMER_LENGTH && typing) {\r\n          socket.emit('stop typing');\r\n          typing = false;\r\n        }\r\n      }, TYPING_TIMER_LENGTH);\r\n    }\r\n  };\r\n\r\n  // Gets the 'X is typing' messages of a user\r\n  const getTypingMessages = (data) => {\r\n    return document.querySelectorAll('.typing.message[username=\"'+data.username+'\"]');\r\n  };\r\n  // Gets the color of a username through our hash function\r\n  const getUsernameColor = (username) => {\r\n    // Compute hash code\r\n    let hash = 7;\r\n    for (let i = 0; i < username.length; i++) {\r\n      hash = username.charCodeAt(i) + (hash << 5) - hash;\r\n    }\r\n    // Calculate color\r\n    const index = Math.abs(hash % COLORS.length);\r\n    return COLORS[index];\r\n  };\r\n\r\n  // Keyboard events\r\n\r\n  window.addEventListener('keydown', event => {\r\n    \r\n    // When the client hits ENTER on their keyboard\r\n    if (event.which === 13) {\r\n      if (username) {\r\n        sendMessage();\r\n        socket.emit('stop typing');\r\n        typing = false;\r\n      } else {\r\n        setUsername();\r\n      }\r\n    }\r\n  });\r\n\r\n  $inputMessage.addEventListener('input', () => {\r\n    updateTyping();\r\n  });\r\n\r\n  // Click events\r\n\r\n  // Focus input when clicking anywhere on login page\r\n  //$loginPage.addEventListener('click',() => {\r\n  //  $currentInput.focus();\r\n  //});\r\n\r\n  // Focus input when clicking on the message input's border\r\n  //$inputMessage.addEventListener('click',() => {\r\n  //  $inputMessage.focus();\r\n  //});\r\n\r\n  // Socket events\r\n\r\n  // Whenever the server emits 'login', log the login message\r\n  socket.on('login', (data) => {\r\n    if (data !== false) {\r\n      \r\n      $loginPage.style.display = \"none\";\r\n      $chatPage.style.display = \"list-item\";\r\n      $loginPage.removeEventListener('click', ()=>{});\r\n      $currentInput = $inputMessage;\r\n      connected = true;\r\n      // Display the welcome message\r\n      const message = 'Welcome to Socket.IO Chat - ';\r\n      log(message, {\r\n        prepend: true\r\n      });\r\n      addParticipantsMessage(data);\r\n    } else {\r\n      alert(\"Bad Login Info\");\r\n    }\r\n  });\r\n\r\n  // Whenever the server emits 'new message', update the chat body\r\n  socket.on('new message', (data) => {\r\n    addChatMessage(data);\r\n  });\r\n\r\n  // Whenever the server emits 'user joined', log it in the chat body\r\n  socket.on('user joined', (data) => {\r\n    log(`${data.username} joined`);\r\n    addParticipantsMessage(data);\r\n  });\r\n\r\n  // Whenever the server emits 'user left', log it in the chat body\r\n  socket.on('user left', (data) => {\r\n    log(`${data.username} left`);\r\n    addParticipantsMessage(data);\r\n    removeChatTyping(data);\r\n  });\r\n\r\n  // Whenever the server emits 'typing', show the typing message\r\n  socket.on('typing', (data) => {\r\n    addChatTyping(data);\r\n  });\r\n\r\n  // Whenever the server emits 'stop typing', kill the typing message\r\n  socket.on('stop typing', (data) => {\r\n    removeChatTyping(data);\r\n  });\r\n\r\n  socket.on('disconnect', () => {\r\n    log('you have been disconnected');\r\n  });\r\n\r\n  socket.on('reconnect', () => {\r\n    log('you have been reconnected');\r\n    if (username) {\r\n      socket.emit('add user', username);\r\n    }\r\n  });\r\n\r\n  socket.on('reconnect_error', () => {\r\n    log('attempt to reconnect has failed');\r\n  });\r\n\r\n})();\r\n\r\n\r\n\n\n//# sourceURL=webpack://v__arena/./SRC.app/scripts/app.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./SRC.app/scripts/app.js"]();
/******/ 	
/******/ })()
;