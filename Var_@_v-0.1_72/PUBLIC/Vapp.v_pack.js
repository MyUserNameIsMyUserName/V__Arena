/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./app_src/V_Arena_Main.js":
/*!*********************************!*\
  !*** ./app_src/V_Arena_Main.js ***!
  \*********************************/
/***/ (() => {

eval("\n/*jshint esversion: 6 */\n\nconsole.info(\"[ V__ARENA - < Var__v-0.1-72 > ]\");\n(function() {\n  const FADE_TIME = 150; // ms\n  const TYPING_TIMER_LENGTH = 400; // ms\n  const COLORS = [\n    '#e21400', '#91580f', '#f8a700', '#f78b00',\n    '#58dc00', '#287b00', '#a8f07a', '#4ae8c4',\n    '#3b88eb', '#3824aa', '#a700ff', '#d300e7'\n  ];\n\n  const VueryDOM = (elemSelector = null) => {\n    if (elemSelector === null) {\n      return document;\n    } else {\n      var elem = document.querySelector(elemSelector);\n      return elem;\n    }\n  };\n  // Initialize variables\n  const $window = window;\n  const $usernameInput = VueryDOM('.usernameInput'); // Input for username\n  const $messages = VueryDOM('.messages');           // Messages area\n  const $inputMessage = VueryDOM('.inputMessage');   // Input message input box\n\n  const $loginPage = VueryDOM('.login.page');        // The login page\n  const $chatPage = VueryDOM('.chat.page');          // The chatroom page\n\n  const socket = io();\n\n  // Prompt for setting a username\n  let username;\n  let connected = false;\n  let typing = false;\n  let lastTypingTime;\n  let $currentInput = $usernameInput;\n\n  const addParticipantsMessage = (data) => {\n    let message = '';\n    if (data.numUsers === 1) {\n      message += `there's 1 participant`;\n    } else {\n      message += `there are ${data.numUsers} participants`;\n    }\n    log(message);\n  };\n\n  // Sets the client's username\n  const setUsername = () => {\n    username = cleanInput($usernameInput.value.trim());\n\n    // If the username is valid\n    if (username) {\n      $loginPage.style.display = \"none\";\n      $chatPage.style.display = \"list-item\";\n      $loginPage.removeEventListener('click', ()=>{});\n      $currentInput = $inputMessage;\n\n      // Tell the server your username\n      socket.emit('add user', username);\n    }\n  };\n\n  // Sends a chat message\n  const sendMessage = () => {\n    let message = $inputMessage.value;\n    // Prevent markup from being injected into the message\n    message = cleanInput(message);\n    // if there is a non-empty message and a socket connection\n    if (message && connected) {\n      $inputMessage.value = \"\";\n      addChatMessage({ username, message });\n      // tell server to execute 'new message' and send along one parameter\n      socket.emit('new message', message);\n    }\n  };\n\n  // Log a message\n  const log = (message, options) => {\n    const $el = '<li class=\"log\">'+(message)+'</li>';\n    addMessageElement($el, options);\n  };\n\n  // Adds the visual chat message to the message list\n  const addChatMessage = (data, options = {}) => {\n    // Don't fade the message in if there is an 'X was typing'\n    const $typingMessages = getTypingMessages(data);\n    if ($typingMessages.length !== 0) {\n      options.fade = false;\n      $typingMessages.forEach( item => {\n        item.remove();\n      });\n    }\n\n    const $usernameDiv = '<span class=\"username\" style=\"color : '+getUsernameColor(data.username)+'\">'+data.username+'</span>';\n    const $messageBodyDiv = '<span class=\"messageBody\">'+(data.message)+'</span>';\n\n    const typingClass = data.typing ? 'typing' : '';\n    const $messageDiv = '<li class=\"message '+typingClass+'\" username=\"'+data.username+'\">'+$usernameDiv + $messageBodyDiv + '</li>';\n\n    addMessageElement($messageDiv, options);\n  };\n\n  // Adds the visual chat typing message\n  const addChatTyping = (data) => {\n    data.typing = true;\n    data.message = 'is typing';\n    addChatMessage(data);\n  };\n\n  // Removes the visual chat typing message\n  const removeChatTyping = (data) => {\n    getTypingMessages(data).forEach( item => {\n      item.remove();\n    });\n  };\n\n  // Adds a message element to the messages and scrolls to the bottom\n  // el - The element to add as a message\n  // options.fade - If the element should fade-in (default = true)\n  // options.prepend - If the element should prepend\n  //   all other messages (default = false)\n  const addMessageElement = (el, options) => {\n    const $el = el;\n    // Setup default options\n    if (!options) {\n      options = {};\n    }\n    if (typeof options.fade === 'undefined') {\n      options.fade = true;\n    }\n    if (typeof options.prepend === 'undefined') {\n      options.prepend = false;\n    }\n\n    // Apply options\n    //if (options.fade) {\n    //  $el.hide().fadeIn(FADE_TIME);\n    //}\n    if (options.prepend) {\n      $messages.insertAdjacentHTML('afterbegin', $el);\n    } else {\n      $messages.insertAdjacentHTML('beforeend', $el);\n    }\n    // First check that the element has child nodes\n    if ($messages.hasChildNodes()) {\n      let children = $messages.childNodes;\n      console.info(\"CHILDREN >> \" + children.length);\n      for (let i = 0; i < children.length; i++) {\n        // do something with each child as children[i]\n        // NOTE: List is live! Adding or removing children will change the list's `length`\n        children[0].scrollTop = children[0].scrollHeight;\n      }\n    }\n  };\n\n  // Prevents input from having injected markup\n  const cleanInput = (input) => {\n    return input;\n  };\n\n  // Updates the typing event\n  const updateTyping = () => {\n    if (connected) {\n      if (!typing) {\n        typing = true;\n        socket.emit('typing');\n      }\n      lastTypingTime = (new Date()).getTime();\n\n      setTimeout(() => {\n        const typingTimer = (new Date()).getTime();\n        const timeDiff = typingTimer - lastTypingTime;\n        if (timeDiff >= TYPING_TIMER_LENGTH && typing) {\n          socket.emit('stop typing');\n          typing = false;\n        }\n      }, TYPING_TIMER_LENGTH);\n    }\n  };\n\n  // Gets the 'X is typing' messages of a user\n  const getTypingMessages = (data) => {\n    return document.querySelectorAll('.typing.message[username=\"'+data.username+'\"]');\n  };\n  // Gets the color of a username through our hash function\n  const getUsernameColor = (username) => {\n    // Compute hash code\n    let hash = 7;\n    for (let i = 0; i < username.length; i++) {\n      hash = username.charCodeAt(i) + (hash << 5) - hash;\n    }\n    // Calculate color\n    const index = Math.abs(hash % COLORS.length);\n    return COLORS[index];\n  };\n\n  // Keyboard events\n\n  window.addEventListener('keydown', event => {\n    // Auto-focus the current input when a key is typed\n    if (!(event.ctrlKey || event.metaKey || event.altKey)) {\n      $currentInput.focus();\n    }\n    // When the client hits ENTER on their keyboard\n    if (event.which === 13) {\n      if (username) {\n        sendMessage();\n        socket.emit('stop typing');\n        typing = false;\n      } else {\n        setUsername();\n      }\n    }\n  });\n\n  $inputMessage.addEventListener('input', () => {\n    updateTyping();\n  });\n\n  // Click events\n\n  // Focus input when clicking anywhere on login page\n  $loginPage.addEventListener('click',() => {\n    $currentInput.focus();\n  });\n\n  // Focus input when clicking on the message input's border\n  $inputMessage.addEventListener('click',() => {\n    $inputMessage.focus();\n  });\n\n  // Socket events\n\n  // Whenever the server emits 'login', log the login message\n  socket.on('login', (data) => {\n    connected = true;\n    // Display the welcome message\n    const message = 'Welcome to Socket.IO Chat - ';\n    log(message, {\n      prepend: true\n    });\n    addParticipantsMessage(data);\n  });\n\n  // Whenever the server emits 'new message', update the chat body\n  socket.on('new message', (data) => {\n    addChatMessage(data);\n  });\n\n  // Whenever the server emits 'user joined', log it in the chat body\n  socket.on('user joined', (data) => {\n    log(`${data.username} joined`);\n    addParticipantsMessage(data);\n  });\n\n  // Whenever the server emits 'user left', log it in the chat body\n  socket.on('user left', (data) => {\n    log(`${data.username} left`);\n    addParticipantsMessage(data);\n    removeChatTyping(data);\n  });\n\n  // Whenever the server emits 'typing', show the typing message\n  socket.on('typing', (data) => {\n    addChatTyping(data);\n  });\n\n  // Whenever the server emits 'stop typing', kill the typing message\n  socket.on('stop typing', (data) => {\n    removeChatTyping(data);\n  });\n\n  socket.on('disconnect', () => {\n    log('you have been disconnected');\n  });\n\n  socket.on('reconnect', () => {\n    log('you have been reconnected');\n    if (username) {\n      socket.emit('add user', username);\n    }\n  });\n\n  socket.on('reconnect_error', () => {\n    log('attempt to reconnect has failed');\n  });\n\n})();\n\n\n\n\n//# sourceURL=webpack://v__arena/./app_src/V_Arena_Main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./app_src/V_Arena_Main.js"]();
/******/ 	
/******/ })()
;